
<!-- saved from url=(0066)http://www.teach.cs.toronto.edu/~csc209h/winter/labs/lab6-gdb.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252"></head><body><h1 id="lab-6-using-the-debugger">Lab 6: Using the Debugger</h1>
<p><strong>Due date</strong>: Friday 16 February before 6:30pm.</p>
<h2 id="introduction">Introduction</h2>
<p>The main purpose of this lab is to give you some practice using the debugger. Before that, we have one more string function for you to write.</p>
<h2 id="starting">Starting</h2>
<p>As usual, go to lab6 on Markus and then pull your repo to trigger the downloading of the starter code.</p>
<h2 id="more-practice-with-strings">More Practice with Strings</h2>
<p>Complete the program <code>copy.c</code> according to the instructions in the starter code.</p>
<h2 id="using-gdb">Using gdb</h2>
<p>It's common for programmers to debug using <em>print</em>, at least for simple issues, but debugging with print statements will become increasingly difficult as we delve into systems programming. Now is the time to learn how to use a common C debugger, <code>gdb</code>. It'll seem hard at first, but you'll be thankful for these skills at the end of this course and in courses like CSC369.</p>
<p>To demonstrate that you've completed the lab, you'll submit a <code>script</code> record of your interactions on the command line to your git repository. Try it out by typing <code>script</code> then typing a few unix commands. Perhaps make a directory for your work on this lab or list the files in your current directory or whatever you wish... Then after you've done something, type <code>exit</code>. This will stop recording your actions and save them in a file named <code>typescript</code>. Check out the <em>man</em> page for script to see that you can give it a filename as an argument to override this default name.</p>
<p>The file <code>overflow.c</code> (in your repo in <code>lab6</code>) contains a program to explore. You will change the values of <code>SIZE</code> and <code>OVERFLOW</code> to see what happens when <code>OVERFLOW</code> is bigger than <code>SIZE</code>.</p>
<p>First, read through the program and explain what it is doing aloud to yourself (or to some unsuspecting bystander, if you prefer). Notice that we are printing the addresses of the variables. The purpose of doing that is to show where the variables are placed in memory.</p>
<p>Next, compile and run the program as shown here:</p>
<pre><code>$ gcc -Wall -g -o overflow overflow.c
$ ./overflow</code></pre>
<p>Don't miss the <code>-g</code> flag or gdb won't work properly. Check the values of <em>before</em>, <em>a</em>, and <em>after</em> -- did the program behave as expected?</p>
<p>Now change the value of <code>OVERFLOW</code> to 5. Compile the program and run it again. What changed? (If nothing changed -- if everything still seems okay -- then try this code on a lab machine. It depends on how the variables are placed into memory by the compiler, and your compiler may be doing something we didn't expect.)</p>
<p>Let's see why variables other than <em>a</em> were affected. The next step is to run the program in <code>gdb</code>. Here are a list of the 9 need-to-know commands in gdb:</p>
<table>
<tbody>
<tr class="odd">
<td align="left">gdb <em>executable</em></td>
<td align="left">start gdb on this executable</td>
</tr>
<tr class="even">
<td align="left">list [n]</td>
<td align="left">list some of the code starting from line n or from the end of last call to list</td>
</tr>
<tr class="odd">
<td align="left">break [n or fun_name]</td>
<td align="left">set a breakpoint either at line n or at the beginning of the function fun_name</td>
</tr>
<tr class="even">
<td align="left">run [args]</td>
<td align="left">begin execution with these command-line arguments</td>
</tr>
<tr class="odd">
<td align="left">next</td>
<td align="left">execute one line</td>
</tr>
<tr class="even">
<td align="left">print <em>variable or expression</em></td>
<td align="left">print the value once</td>
</tr>
<tr class="odd">
<td align="left">display <em>variable or expression</em></td>
<td align="left">print the value after every gdb command</td>
</tr>
<tr class="even">
<td align="left">continue</td>
<td align="left">execute up to the next breakpoint</td>
</tr>
<tr class="odd">
<td align="left">quit</td>
<td align="left">bye-bye!</td>
</tr>
</tbody>
</table>
<p>Try this out on your overflow executable. Start by typing <code>gdb overflow</code>. Set a breakpoint in main by typing <code>break main</code>, and then start the program running by typing <code>run</code>. You want to watch the values of a few variables, so use <code>display</code> to show the value of some variables. Do this for each variable you want to watch. Step through the program one line at a time using <code>next</code> (after you enter <code>next</code> once, you can execute another line by just hitting "enter"). Keep a close eye on the first element in <code>after</code>, and notice the final value of <code>a</code>. When the program terminates, type <code>quit</code> to leave gdb.</p>
<p>Now start <code>gdb</code> again but before you start, use <code>script</code> to record your interaction. (You'll submit this script.) This time make sure you watch the array <code>after</code>. It is pretty slow to step through every line of your code, so use <code>list</code> to find the line number of the for loop where we start to assign values to the array. Set a breakpoint on that line number and then use <code>continue</code> to jump to the breakpoint you just set. Use <code>next</code> to step through one line at a time. Watch the value of <code>after[0]</code> carefully. When it changes, print its address. (Yes, you can do "<code>print &amp;(after[0])</code>" inside <code>gdb</code>.) Then, print the address of <code>a[4]</code>. Does that help you understand what happened? Exit <code>gdb</code>. (Say 'y' when it asks if you want to Quit anyway.) Then exit your script. Rename the script file you generated to <code>gdb_example.txt</code> and add it to your repository.</p>
<p>The last step is to try to make your program crash. (I had to set <code>OVERFLOW</code> to something like 5000 to get it to crash with a Segmentation fault.) Once you've found a value for <code>OVERFLOW</code> that produces a Segmentation fault, run the program in <code>gdb</code> without setting a breakpoint so that it runs automatically until the crash. Then use the <code>backtrace</code> command and the <code>print</code> command to investigate the value for <code>i</code>. Try <code>backtrace full</code> for even more helpful information. You don't need to record what you're doing on this step. We just want you to see the <code>backtrace</code> command.</p>
<h2 id="submitting-your-work">Submitting Your Work</h2>
<p>Make sure that <code>gdb_example.txt</code> is added to the <code>lab6</code> directory. Remember to add, commit and push all changes to <code>copy.c</code> and <code>gdb_example.txt</code>. Do not commit any executables or any other additional files.</p>
<p>We will be auto-testing your solution to <code>copy.c</code> so you must not change the signature. We will not be auto-grading your scripts but reading them. So if you have extra steps during your debugging, this is fine. We aren't expecting that every student's script will be the same.</p>
</body></html>